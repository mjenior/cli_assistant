import re
import os
import requests
from collections import defaultdict

from openai import OpenAI

from src.lib import extDict


class OpenAIInterface:
    """
    Handles OpenAI API interactions including assembling, submitting, and processing queries.
    """

    def __init__(self, manager):
        """
        Initializes the query handler with the provided variables.
        """
        self.client = OpenAI()
        self.query = self._assemble_query(manager)
        
    def _assemble_query(self, manager):
        """
        Assembles the query dictionary for the API request.
        """
        query = [
            {"role": "user", "content": manager.prompt},
            {"role": "system", "content": manager.role}
        ]
        if manager.reflection:
            query.append({"role": "assistant", "content": manager.reflection})
        
        return query

    def submit_query(self, manager):
        """
        Submits the query to OpenAI's API and processes the response.
        """
        if not manager.silent:
            print("\nThinking...\n")
        if manager.label not in ["artist", "photo"]:
            return self._process_text_response(manager)
        return self._process_image_response(manager)

    def _process_text_response(self, manager):
        """
        Processes text-based responses from OpenAI's chat models.
        """
        self.reponse_type = "reponse"
        response = self.client.chat.completions.create(
            model=manager.model, messages=self.query
        )
        message = response.choices[0].message.content
        if not manager.silent:
            print(f"\nResponse:\n{message}\n")

        if manager.code:
            os.makedirs('code', exist_ok=True)
            scripts = self._extract_code_from_reponse(message, manager.timestamp)
            if scripts and not manager.silent:
                print(f"\nCode extracted from reponse text and saved to:\n\t{'\n\t'.join(scripts)}\n")

    def _process_image_response(self, manager):
        """
        Processes image generation requests using OpenAI's image models.
        """
        self.reponse_type = "revised_prompt"
        os.makedirs('images', exist_ok=True)
        response = self.client.images.generate(
            model=manager.model,
            prompt=manager.prompt,
            n=1,
            size=manager.size,
            quality=manager.quality
        )
        revised_prompt = response.data[0].revised_prompt
        if not manager.silent:
            print(f"Revised prompt:\n{revised_prompt}")

        image_data = requests.get(response.data[0].url).content
        image_file = f"images/{manager.model.replace('-', '')}.{manager.timestamp}.image.png"
        with open(image_file, 'wb') as outFile:
            outFile.write(image_data)
        if not manager.silent:
            print(f"\nGenerated image saved to: {image_file}")

        if manager.log:
            self._save_response_text(revised_prompt, manager)

    def _save_response_text(self, message, manager):
        """
        Saves the current response text to a file if specified.
        """
        outFile = f"responses/{manager.label}.{manager.model.replace('-', '')}.{manager.timestamp}.{self.reponse_type}.txt"
        os.makedirs('responses', exist_ok=True)
        with open(manager.transcript_file, "a", encoding="utf-8") as file:
            file.write(message)

        if not manager.silent:
            print(f"\nResponse text saved to: {outFile}")

    def _extract_code_from_reponse(self, response, timestamp):
        """
        Extracts and saves code snippets from the response into separate files.
        """
        # Initialize variables
        pyObjects = defaultdict(list)
        pyObjects["current_code"] = ["# Code generated by ChatGPT\n"]

        # Split response into lines and process
        for line in response.splitlines():
            line = line.strip()

            # Start or end of a code block
            if line.startswith("```"):
                if len(pyObjects["current_code"]) > 2:  # End of a code block
                    pyObjects["code"] = "\n".join(pyObjects["current_code"])

                    # Determine output filename
                    name = self._select_outfile_ext(pyObjects['classes'], pyObjects['functions'], lang)
                    file_name = f"code/{name}.{timestamp}{extDict.get(lang, f".{lang}")}".lstrip('_')
                    pyObjects['files'].append(file_name)

                    # Save code snippet to file
                    os.makedirs("code", exist_ok=True)
                    with open(file_name, "w", encoding="utf-8") as file:
                        file.write(pyObjects["code"])

                    # Reset code accumulator
                    pyObjects["current_code"] = ["# Code generated by ChatGPT\n"]

                else:  # Start of a new code block
                    lang = line.replace("```", "").lower()
                    pyObjects["current_code"].append(lang.capitalize())

            # Process lines within a code block
            elif len(pyObjects["current_code"]) > 1:
                pyObjects["current_code"].append(line)
                if len(line.strip()) > 0 and line.split()[0] in ['def', 'class']:
                    f, c = self._scrape_object_name(line)
                    pyObjects['functions'].append(f)
                    pyObjects['classes'].append(c)

        return pyObjects["files"]

    @staticmethod
    def _select_outfile_ext(classes, funcs, lng):
        """
        Select name for code files based on generated functions and classes
        """
        classes = [x for x in classes if len(x.strip()) >= 1]
        funcs = [x for x in funcs if len(x.strip()) >= 1]
        if len(classes) != 0:
            name = max(classes, key=len, default=lng)
        else:
            name = max(funcs, key=len, default=lng)

        return max([name, 'code'], key=len)

    @staticmethod
    def _scrape_object_name(line):
        """
        Extracts a meaningful name for a script or class from the provided line of text.
        """
        name = line.split()[1].split('(')[0].lower()
        name = re.sub(r'[^0-9a-zA-Z]+', '_', name)
    
        func, clss = '', ''
        if line.startswith("def ") and " main(" not in line:
            func = name
        elif line.startswith("class "):
            clss = name

        return func, clss
